# 05. 프로세스 상태와 스케쥴링

## 멀티 프로그래밍과 wait

<center><img src="https://t1.daumcdn.net/cfile/tistory/2103FF375949D3C216"></center>

* 멀티 프로그래밍
  * CPU 활용도를 극대화 하는 스케쥴링 알고리즘

* Wait
  * 저장매체로부터 파일 읽기를 기다리는 시간으로 가정.

## 프로세스 상태

<center> <img src="https://images.velog.io/post-images/pa324/f6834b00-e19f-11e9-a254-b9025233ee3c/image.png"></center>

* 멀티 프로그래밍에서 프로세스 상태에 따라 CPU가 작업을 진행한다.
  * new
    * 프로세스 생성 중인 상태
  * running state
    * 현재 CPU에서 실행 상태
    * **싱글 코어**라면 running state는 0~1개.
    * running 상태는 `특정 이벤트를 통하여 block 상태로 변경되거나, 실행이 완료되어 ready로 변경됨.`
  * ready state
    * CPU에서 실행 가능 상태(실행 대기 상태)
    * ready 상태는 `스케쥴러가 대기 중인 프로세스를 선택하여 running 상태로 변경됨`
  * block state
    * 특정 이벤트 발생 대기 상태
      * ex1) 저장매체에 파일 읽기를 요청한 경우 파일을 다 읽을 때까지 대기
      * ex2) 프린트 출력이 다 될때까지 대기
    * `이벤트 종료시 ready 상태로 변경`
  * exit
    * 프로세스 시스템 자원들 종료

## 기본적인 프로세스 상태별 처리 방식

* 프로세스 상태별 queue를 활용하여 처리 순서를 각각 보장한다.
  * running state queue
  * ready state queue
  * block state queue

* queue 기반으로 우선순위나 SJF를 활용하여 응용이 가능.

## 선점형과 비선점형 스케쥴러

![선점형_비선점형_스케쥴러](./img/선점형_비선점형_스케쥴러.png)

* 선점형 스케쥴러 (Preemptive Seheduling)
  * 하나의 프로세스가 다른 프로세스 대신에 프로세서를 차치할 수 있음
  * 시분할 시스템에서는 선점형 스케쥴러.
  * 프로세스 running 중에 스케쥴러가 이를 `중단 시키고, 다른 프로세스로 교체` 가능
  * RoundRobin 알고리즘

* 비선점형 스케쥴러 (Non-preemptive Scheduling)
  * 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음
  * 프로세스가 `자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만` 다른 프로세스로 교체 가능
  * FIFO, SJF, Priority-based 알고리즘

* 스케쥴러는 복합적으로 알고리즘을 조합하여 구성될 수 잇다.

## 마우스 / 키보드 반응이 느린 경우

* 스케쥴러가 해결해야하는 이슈임
* 다양하고 복잡한 스케쥴링 알고리즘 필요
* 리눅스 스케쥴러
  * O(1), CFS와 같이 다양한 방식으로 변경시도 중
    * 인터렉티브, IO, CPU 중심 프로세스로 미리 구분할 수 있다며 보다 개선된 스케쥴링이 가능함