# 06. 인터럽트

## 인터럽트란

* CPU는 Program Counter 코드 한줄만 집중하여 실행.
* 인터럽트는 CPU가 작업 처리 중 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술
  * 선점형 스케쥴러에서 실행중인 프로세스를 ready 상태로 변경하기 위해 필요함
  * IO Device의 처리 완료시, 프로세스를 깨워야 함 ( block -> ready )
    * 파일처리가 끝났을 때 운영체제에 알려주기
  * 입출력 하드웨어 등의 장치나 프로그래램 처리 중 **예외상황**이 발생할 경우 CPU에 알려줘야함.
    * 0으로 나누는 계산이 발생해서, 예외 발생을 운영체제에 알려주기
* 인터럽트는 일종의 **이벤트**로 불림
* `이벤트에 맞게 운영체제가 처리`함

## 주요 인터럽트 (Interrupt)

* 계산하는 코드에서 0으로 나누는 코드 실행시 ( Divide-by-Zero Interrupt)
  * C언어는 0으로 나눌 경우 예외 발생.

```C
#include <stdio.h>

int main()
{
  printf("Hello World\n");
  int data;
  int divider = 0;
  data = 1 / divider; // 해당 코드 실행시 예외 발생.
  return 0;
}
```

```text
Hello World!
Floating point exception (core dumped) // 예외 발생시 운영체제 인터럽트 처리 루틴이 출력
```

* 타이머 인터럽트
  * `선점형 스케쥴러를 위해 필요`
  * 하드웨어로 부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려줌

* 입출력(IO) 인터럽트
  * 프린터, 키보드, 마우스, 저장매체 등등

## 인터럽트 종류

### 내부 인터럽트 ( 소프트웨어 인터럽트 )

* 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
  * C언어 기준으로 아래 케이스에서 발생하는 예외들
    * 0으로 나눴을 때
    * 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
      * UNIX에서 기본적으로 0G~4G 까지 하나의 프로세스 공간으로 정의
        * 0G~3G 까지는 사용자 모드
        * 3G~4G 까지는 커널 모드
      * `사용자 모드로 커널 모드에 해당하는 메모리 접근`시 발생
    * 계산 결과가 Overflow/Underflow 발생시

### 외부 인터럽트 ( 하드웨어 인터럽트 )

* 주로 하드웨어에서 발생하는 이벤트
  * 전원 이상
  * 기계 문제
  * 키보드등 IO 관련 이벤트
  * Timer 이벤트

## 시스템 콜 인터럽트

* 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.
* 시스템 콜 실제 코드
  * eax 레지스터에 시스템 콜 번호를 넣고,
  * ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,
  * 스프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌

```C
mov ebx, 1
mov ebx, 0
int 0x80 // 소프트웨어 인터럽트 명령
```

> 시스템 콜 호출시 처리 순서
>
> 1. CPU는 사용자 모드를커널 모드로 바꿔줌
> 2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행
> 3. system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
> 4. 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음코드 진행

## 사용자/커널 모드와 프로세스, 인터럽트

* 프로세스 실행 중 시스템 콜이나 Timer Interrupt 발생시마다 Kernel Mode로 변경되어 처리된다.

## 인터럽트와 IDT

* 인터럽느틑 미리 정의되어 각각 번호와 실행 코드를 가라키는 주소가 기록되어 있음
  * 어디에? IDT(Interrupt Descriptor Table)에 기록
  * 언제? 컴퓨터가 부팅시 운영체제가 기록
  * 어떤 코드? 운영체제 내부 코드

* 인터럽트 발생시
  * 항상 인터럽트 발생시 ,IDT 확인
  * 시스템콜 인터럽트 명령은 0x80번호가 미리 정의
  * 인터럽트 0x80에 해당하는 운영체제 코드는 system_call() 이라는 함수
  * 즉, IDT에는 0x80 -> system_call() 와 같은 정보가 기록되어 있음

* 리눅스에서 설정된 IDT
  * 0~31 : 예외상황 인터럽트 ( 일부는 정의안된 채로 남겨져 있음)
  * 32~47 : 하드웨어 인터럽트 ( 주변장치 종류/갯수에 따라 변경 가능)
  * 128 : 시스템 콜

## 인터럽트와 프로세스

1. 프로세스 실행 중 인터럽트 발생
2. 현 프로세스 실행 중단
3. 인터럽트 처리 함수 실행 ( 운영체제 )
    * 커널 모드에서 인터럽트에 해당하는 함수 실행
4. 현 프로세스 재실행

## 인터럽트와 스케쥴러

### 선점형 스케쥴러

* 수시로 타이머 인터럽트 발생함.
  * 운영체제가 타이머 인터럽트발생 횟수를 기억해서 5번 타이머 인터럽트 발생시 현재 프로세스를 다른 프로세스로 바꿔준다.
