# 11. 가상메모리

* 프로레스별로 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
* 리눅스는 하나의 프로세스가 4GB임
  * 통상 메모리는 8GB나 16GB
* 폰노이만 구조는 코드는 메모리에 반드시 있어야함
* 여러 프로세스가 동시 실행 시스템에서는 필수적으로 필요함.

## 가상 메모리 기본 아이디어

* 프로세스는 **가상 주소**를 사용하고, 실제 해당 주소에서 **데이터를 읽고/쓸때만 물리주소**로 바꿔주면 된다.
* virtual address \( 가상 주소 \) : 프로세스가 참조하는 주소
  * CPU가 먼저 참조하는 주소
* physcial address \( 물리 주소 \) : 실제 메모리 주소

### MMU \( Memory Management Unit \)

* CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
* CPU는 가상메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  * 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠

## 페이징 시스템 \(paging system\)

* 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
* 하드웨어 지원이 필요
* 리눅스에서는 4KB로 paging
  * Intel x86 시스템\(32bit\)에서는 4KB, 2MB, 1GB 지원
* 프로세스\(4GB\)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음
* 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

## 페이지 테이블 \(page table\)

* 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
* Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음
  * 가상주소 v = \(p, d\)
    * p: 가상 메모리 페이지
    * d: p 안에서 참조하는 위치 \( 변위라고도 한다 \)
      * 해당 프로세스의 PCB의 page table에 해당 가상 주소가 포함된 page 번호가 있는지 확인
      * page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고 \(p\)
      * p + d 가 실제 물리 주소가 됨
* 페이지 크기가 4KB일 때 예제
  * 가상 주소의 0비트에서 11비트가 변위 \(d\) 를 나타냄
  * 12비트 이상이 페이지 번호가 될 수 있음

## 페이징 시스템

### MMU

* CPU는 가상 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근한다.
* 프로세스 생성시, 페이지 테이블 정보를 생성한다.
  1. PCB 등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
  2. 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장\(CR3\)
  3. CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴

### TLB \( Translation Lookaside Buffer \)

* 페이지 정보 캐쉬
* MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
  * CR3를 통한 페이징 테이블 접근하여 실제 메모리 주소 조회
  * 메모리 주소를 접근하여 실제 데이터를 CPU로 전달
* 위의 과정에서 물리 메모리 주소 조회시 TLB에 캐싱하여 메모리 접근을 최소화함.

### 다중 단계 페이징 시스템

* 페이징 정보를 단계를 나누어 생성함.
  * 필요없는 페이지는 생성하지 않으면, 공간 절약 가능함

![&#xB2E4;&#xC911; &#xD398;&#xC774;&#xC9D5;](https://mblogthumb-phinf.pstatic.net/20130620_234/jevida_1371715145335O6yo8_PNG/1.png?type=w2)

### 공유 메모리

* 프로세스간 동일한 물리 주소를 가리킬 수 있음 \( 공간 절약, 메모리 할당 시간 절약 \)
  * 공간절약
    * 32bit 기준으로 프로세스별로 4g의 메모리를 기준으로 실행됨.
    * 4g에서 커널\(3g ~ 4g\)에 해당하는 영역을 **페이지 테이블을 통하여 동일한 메모리를 사용하여 최적화** 가능하다.
  * 메모리 할당 시간 절약
    * fork를 통하여 자식 프로세스도 4g로 프로세스가 실행됨.
    * 이때, 페이지 테이블을 통하여 부모 프로세스와 동일한 메모리를 사용하여 할당시간을 감소한다.
    * 단, 부모와 동일하게 바라보고 있던 데이터 수정 시도시, 물리 주소를 복사할 수 있다.  

### 요구 페이징 \( Demand Paging 또는 Damanded Paging \)

* 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
  * 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 \( 페이지 교체 알고리즘 필요 \)
  * 선행 페이징\( anticipatory paging 또는 prepaging \)의 반대 개념.
    * 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념.

### 페이지 폴트

* 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트.
* page fault가 일어나면 운영체제가 해당 페이지를 물리 메모리에 올림.
* 페이지 폴트가 자주 일어난다면 시간이 오래 걸린다.
  * 실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함
  * 향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 될까?
    * 앞으로 있을 일을 예측해야 함 - 신의 영역
* 프로그램이 과도하게 올라간다면 페이지 폴트가 빈번하게 발생하여 아무것도 하지 못하는 상황이 발생할 수 있다.
  * 스레싱\(Thrashing\) 이라고 한다.

![&#xD398;&#xC774;&#xC9C0; &#xD3F4;&#xD2B8;](http://www.driveronline.org/clubarea/myImg/070409144339.jpg)

### 페이지 교체 정책 \( page replacement policy \)

* 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면?
  * 기존 페이지 중 하나를 물리 메모리에서 저장 매채로 내리고 \( 저장하고 \)
  * 새로운 페이지를 해당 물리 메모리 공간에 올린다.

### 페이지 교체 알고리즘

* 교체 정책을 위해서 알고리즘 들이 고안됨
  * FIFO
    * 가장 먼저 들어온 페이지를 내린다.
  * OPT \( OPTimal Replacement Algorithm\)
    * 앞으로 가장 오랫동안 사용하지 않 을 페이지를 내린다.
    * 신의 영역
  * LRU \( Least Recently Used \)
    * 가장 오래된 사용하지 않은 페이지를 내린다.
    * 메모리 지역성을 근거로 가장 많이 사용하는 알고리즘이다.
  * LFU \( Least Frequently Used\)
    * 가장 적게 사용된 페이지를 내린다.
  * NUR \( Not Used Recently \)
    * 페이지 스왑 알고리즘
    * LRU 와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 방법
    * 각 페이지마다 참조 비트\(R\), 수정 비트\(M\)을 둠 \(R, M\)
      * \(0,0\), \(0,1\), \(1,0\), \(1,1\) 순으로 페이지 교체

### 쓰레싱

* 반복적으로 페이지 폴트가 발생해서 과도하게 페이지 교체 작업이 일어나 실제로는 아무일도 못하는 상황

## 세그멘테이션 기법

* 가상 메모리를 서로 크키가 다른 논리적 단위인 세그먼트로 분할
  * 페이징 기업에서는 가상 메모리를 같은 크기의 블록으로 분할
  * 예 : x86 리얼모드
    * CS\(Code Segment\), DS\(Data Segment\), SS\(Stack Segment\), ES\(Extra Segment\) 로 세그먼트를 나누어 메모리로 접근
    * 우리가 알고있는 윈도우 안전모드를 생각해보자.
* 세그먼트 가상주소
  * v=\(s,d\): s는 세그먼트 번호, d는 블록 내 세그먼트의 변위
* 세그멘테이션은 크기가 다른 segment 단위로 물리 메모리에 로딩
  * 페이지는 고정된 사이즈로 생성함

