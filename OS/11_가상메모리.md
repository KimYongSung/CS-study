# 11. 가상메모리

* 프로레스별로 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
* 리눅스는 하나의 프로세스가 4GB임
  * 통상 메모리는 8GB나 16GB

* 폰노이만 구조는 코드는 메모리에 반드시 있어야함
* 여러 프로세스가 동시 실행 시스템에서는 필수적으로 필요함.

## 가상 메모리 기본 아이디어

* 프로세스는 **가상 주소**를 사용하고, 실제 해당 주소에서 **데이터를 읽고/쓸때만 물리주소**로 바꿔주면 된다.
* virtual address ( 가상 주소 ) : 프로세스가 참조하는 주소
  * CPU가 먼저 참조하는 주소
* physcial address ( 물리 주소 ) : 실제 메모리 주소

### MMU ( Memory Management Unit )
  
* CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
* CPU는 가상메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  * 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠

## 페이징 시스템 (paging system)

* 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
* 하드웨어 지원이 필요
* 리눅스에서는 4KB로 paging
  * Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
* 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음
* 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

## 페이지 테이블 (page table)

* 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
* Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음
  * 가상주소 v = (p, d)
    * p: 가상 메모리 페이지
    * d: p 안에서 참조하는 위치 ( 변위라고도 한다 )
      * 해당 프로세스의 PCB의 page table에 해당 가상 주소가 포함된 page 번호가 있는지 확인
      * page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고 (p)
      * p + d 가 실제 물리 주소가 됨

* 페이지 크기가 4KB일 때 예제
  * 가상 주소의 0비트에서 11비트가 변위 (d) 를 나타냄
  * 12비트 이상이 페이지 번호가 될 수 있음

## 페이징 시스템

### MMU

* CPU는 가상 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근한다.
* 프로세스 생성시, 페이지 테이블 정보를 생성한다.
  1. PCB 등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
  2. 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  3. CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴

### TLB ( Translation Lookaside Buffer )

* 페이지 정보 캐쉬
* MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
  * CR3를 통한 페이징 테이블 접근하여 실제 메모리 주소 조회
  * 메모리 주소를 접근하여 실제 데이터를 CPU로 전달
* 위의 과정에서 물리 메모리 주소 조회시 TLB에 캐싱하여 메모리 접근을 최소화함.

### 다중 단계 페이징 시스템

* 페이징 정보를 단계를 나누어 생성함.
  * 필요없는 페이지는 생성하지 않으면, 공간 절약 가능함

![다중 페이징](https://mblogthumb-phinf.pstatic.net/20130620_234/jevida_1371715145335O6yo8_PNG/1.png?type=w2)

### 공유 메모리

* 프로세스간 동일한 물리 주소를 가리킬 수 있음 ( 공간 절약, 메모리 할당 시간 절약 )

  * 공간절약
    * 32bit 기준으로 프로세스별로 4g의 메모리를 기준으로 실행됨.
    * 4g에서 커널(3g ~ 4g)에 해당하는 영역을 **페이지 테이블을 통하여 동일한 메모리를 사용하여 최적화** 가능하다.
  
  * 메모리 할당 시간 절약
    * fork를 통하여 자식 프로세스도 4g로 프로세스가 실행됨.
    * 이때, 페이지 테이블을 통하여 부모 프로세스와 동일한 메모리를 사용하여 할당시간을 감소한다.
    * 단, 부모와 동일하게 바라보고 있던 데이터 수정 시도시, 물리 주소를 복사할 수 있다.  

